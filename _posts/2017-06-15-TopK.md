---
layout: post
title:  TopK
author: Nroskill
date:   2017-06-15
categories: [Algorithm]
---

# 概述
TopK问题是面试中常见到的问题，描述起来也很简单，现在有N个未排序的数，如何将最大/小的K个数找出来？

## 思路1：无脑排序
无脑排序的话实现起来很简单，把N个数load进内存，然后跑一个快排、归排或堆排即可
> 时间复杂度 O(N * logN)  
> 空间复杂度 O(N)

## 思路2：初步优化
思路1的缺陷在于，额外排序了N-K个数，我们只需要最大/最小的前K个数就可以了，额外排序的部分不仅耗时，也占用更多的内存。
我们可以维护一个有序的数组，用来存储TopK的元素，然后一个个把其余元素load进来，更新这个数组。
> 时间复杂度 O(N * K)  
> 空间复杂度 O(K)

## 思路3：常规方案
上一个思路的缺陷在于，更新数组过于慢了，而想要更新一个有序数组最快的办法，是维护一个堆，所以我们可以把存储TopK元素的数据结构改为最大/小堆（如果要最小的TopK元素，用最大堆，反之用最小堆）。
> 时间复杂度 O(N * logK)  
> 空间复杂度 O(K)

## 思路4：空间换时间
上一个思路还可以优化，原因在于其实最终结果不需要TopK是有序的，只是我们为了维护TopK的数组所增加的操作而已，而利用快排的思路，我们每一步的快排都可以找到第X大的元素，虽然X不一定等于K，但是我们可以逐渐逼近，直到 X == K，那么X和X之前的元素就是我们要的结果。之所以思路3更常见，是因为往往K的值很小，思路4相比思路3优化并不是很明显，但却额外占用大量内存。
> 时间复杂度 O(N)  
> 空间复杂度 O(N)